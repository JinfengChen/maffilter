\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename maffilter.info
@settitle MafFilter Manual 1.0.0
@documentencoding UTF-8
@afourpaper
@dircategory Science Biology Genetics
@direntry
* maffilter: (maffilter)        MAF Filter.
@end direntry
@c %**end of header


@copying
This is the manual of MafFilter, version 1.0.0.

Copyright @copyright{} 2012 Julien Y. Dutheil
@end copying

@titlepage
@title MafFilter Manual
@author Julien Dutheil
@author @email{julien.dutheil@@univ-montp2.fr}


@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1fill1
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top The MafFilter Manual

@insertcopying
@end ifnottex

@menu
* Introduction::                
* Filters::                     

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Description::                 
* Run::                         
* General::                     

Filters

* Extracting::                  
* Cleaning::                    
* Analyzing::                   
* Exporting::                   

@end detailmenu
@end menu

@c ------------------------------------------------------------------------------------------------------------------

@node Introduction, Filters, Top, Top
@chapter Introduction

MafFilter is a program form post-processing genome alignments in the Multiple ALignment Files (MAF) format.
MAF files consist of a series of "blocks", displaying the alignment of subsequences of the original genomes.
In a typical MAF file, such blocks represent synteny blocks.
See the UCSC website for a detailed description of the file format.

How to obtain MAF files is not covered in this manual. Such files are typically generated by packages such as BlastZ, MultiZ, Last or Galaxy, and you should refer to the manual of these resources for more detailed help.
These packages also contain tools for manipulating MAF files, which you might find useful in combination to the program decribed here.

MafFilter is written with the Bio++ libraries, and uses the BppO command line syntax common to the Bio++ Program Suite (BppSuite).
You may refer to the BppSuite manual for more details on this syntax.
Note that several examples are provided along with the source code of the program, and can serve as good training starts.
This manual intends to provide an exhaustive description of the options used in these examples.

@c ------------------------------------------------------------------------------------------------------------------

         
@menu
* Description::                 
* Run::                         
* General::                     
@end menu

@node Description, Run, Introduction, Introduction
@section Description of the program

MafFilter takes as input a MAF file and a series of commands, which can be gathered in an option file.
These commands determine the output file(s) that will be written and where.
Additional input files might be specified, such as gene annotation files (typically in GFF/GTF format).

The main goal of MafFilter is to apply a series of "filters" to the original input file.
A ``filter'' can be seen as a small program that takes as input one or several maf blocks, and outputs one or several maf block, after performing some actions on them:

@verbatim
                         +--------+
   Alignment block(s)    |        |   Alignment block(s)
------------------------>+ Filter +------------------------>
                         |        |
                         +--------+
@end verbatim

We can roughly distinguish three types of filters:

@itemize @bullet
@item
Filters that take one block as input, and output one single block, possibly after removing some sequences, or even the full block if it did not match a certain criterion,
@item
Filters that take one block as input, and split them into several smaller blocks, for instance of a fixed size,
@item
Filters that take several block as input and output a larger one, typically after concatenating the input blocks,
@item
Filters that do not modify the input block and simply forward it, yet after having performed some computations, for instance calculating various statistics.
@end itemize

A run of MafFilter typically consists in a workflow of filters, applied in a serial way, the output of one filter being taken as input as the next one. In the current version fo MafFilter, only linear workflows are possible, without branching. Branching processes can however be achieved by output the alignment blockas at the branching point, and run various instances of MafFilter on the resulting files:

@verbatim
    +----------+    +----------+    +----------+
    |          |    |          |    |          |
--->+ Filter 1 +--->+ Filter 2 +--->+ Filter 3 +---> Etc.
    |          |    |          |    |          |
    +----------+    +----------+    +----------+
@end verbatim

The next section describes how to specify the series of filters to be applied, and the next chapter provides an exhaustive list of available filters.

@c ------------------------------------------------------------------------------------------------------------------

@node Run, General, Description, Introduction
@section How to run the program

The MafFilter program follows the @samp{bppSuite} syntax.
It is command line driven, and take as input options with the form @samp{name}=@samp{value}.
These options can be gathered into a file, and loaded using @command{param=optionfile}.
Please refer to the Bio++ Program Suite manual for more details, including the use of variables, priority of option values, etc.

@c ------------------------------------------------------------------------------------------------------------------

@node General,  , Run, Introduction
@section General options

@table @command

@item input.file=@{path@}
The MAF file to parse

@item input.file.compression=[none|zip|gzip|bzip2]
The compression format of the input file.

@item output.log=@{path@}
The file where to write log messages.

@item maf.filter=@{Filter1, Filter2, ...@}
The main command, specifying the list of filter commands to apply, in the given order (that is, the input of filter 2 will be the output of filter 1).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Filters,  , Introduction, Top
@chapter Filters

@c ------------------------------------------------------------------------------------------------------------------

@menu
* Extracting::                  
* Cleaning::                    
* Analyzing::                   
* Exporting::                   
@end menu

@node Extracting, Cleaning, Filters, Filters
@section Extracting data

@c ------------------------------------------------------------------------------------------------------------------

@node Subset
@subsubsection Subset: remove sequences from blocks

The @command{Subset} filter allows to remove 
      if (cmdName == "Subset") {
        //string speciesList = ApplicationTools::getStringParameter("species", cmdArgs, "none");
        bool strict = ApplicationTools::getBooleanParameter("strict", cmdArgs, false);
        ApplicationTools::displayBooleanResult("-- All species should be in output blocks", strict);
        bool keep = ApplicationTools::getBooleanParameter("keep", cmdArgs, false);
        ApplicationTools::displayBooleanResult("-- Sequences not in the list will be kept", keep);
        bool rmdupl = ApplicationTools::getBooleanParameter("rm.duplicates", cmdArgs, false);
        ApplicationTools::displayBooleanResult("-- Species should be present only once", rmdupl);
        vector<string> species = ApplicationTools::getVectorParameter<string>("species", cmdArgs, ',', "");
        if (species.size() == 0)
          throw Exception("At least one species should be provided for command 'Subset'.");
        //getList(speciesList, species);
        SequenceFilterMafIterator* iterator = new SequenceFilterMafIterator(currentIterator, species, strict, keep, rmdupl);
        iterator->setLogStream(&log);
        iterator->verbose(verbose);
        currentIterator = iterator;
        its.push_back(iterator);
      }


@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------

@node Cleaning, Analyzing, Extracting, Filters
@section Cleaning alignment blocks

@c ------------------------------------------------------------------------------------------------------------------

@node Analyzing, Exporting, Cleaning, Filters
@section Statistical analysis

@c ------------------------------------------------------------------------------------------------------------------
@node Exporting,  , Analyzing, Filters
@section Exporting blocks and data

@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------

@c end of document

@c @node Index,  , Reference, Top
@c @unnumbered Index
@c
@c @printindex cp


@bye
