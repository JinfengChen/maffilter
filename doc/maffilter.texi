\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename maffilter.info
@settitle MafFilter Manual 1.0.0
@documentencoding UTF-8
@afourpaper
@dircategory Science Biology Genetics
@direntry
* maffilter: (maffilter)        MAF Filter.
@end direntry
@c %**end of header


@copying
This is the manual of MafFilter, version 1.0.0.

Copyright @copyright{} 2012 Julien Y. Dutheil
@end copying

@titlepage
@title MafFilter Manual
@author Julien Dutheil
@author @email{julien.dutheil@@univ-montp2.fr}


@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1fill1
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top The MafFilter Manual

@insertcopying
@end ifnottex

@menu
* Introduction::                
* Filters::                     

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Description::                 
* Run::                         
* General::                     

Filters

* Extracting::                  
* Cleaning::                    
* Analyzing::                   
* Exporting::                   

Extracting data

* Subset::                      
* Merge::                       
* Concatenate::                 
* FeatureFilter::               
* SelectChr::                   

Cleaning alignment blocks

* MinBlockLength::              
* MinBlockSize::                
* XFullGap::                    
* AlnFilter::                   
* AlnFilter2::                  
* EntropyFilter::               
* MaskFilter::                  
* QualFilter::                  

@end detailmenu
@end menu

@c ------------------------------------------------------------------------------------------------------------------

@node Introduction, Filters, Top, Top
@chapter Introduction

MafFilter is a program for post-processing genome alignments in the Multiple Alignment Files (MAF) format.
MAF files consist of a series of "blocks", displaying the alignment of subsequences of the original genomes.
In a typical MAF file, such blocks represent synteny blocks.
See the UCSC website for a detailed description of the file format.

How to obtain MAF files is not covered in this manual. MAF files are typically generated by packages such as BlastZ, MultiZ, Last or Galaxy, and you should refer to the manual of these resources for more detailed help.
These packages also contain tools for manipulating MAF files, which you might find useful in combination to the program described here.

Note that several examples are provided along with the source code of the program, and can serve as good training starts.
This manual intends to provide an exhaustive description of the options used in these examples, as well as to provide general information about the way the program works and its underlying algorithms.

@c ------------------------------------------------------------------------------------------------------------------

         
@menu
* Description::                 
* Run::                         
* General::                     
@end menu

@node Description, Run, Introduction, Introduction
@section Description of the program

The main goal of MafFilter is to apply a series of "filters" to the original input file.
A ``filter'' can be seen as a small program that takes as input one or several maf blocks, and outputs one or several maf block, after performing some actions on them:

@verbatim
                         +--------+
   Alignment block(s)    |        |   Alignment block(s)
------------------------>+ Filter +------------------------>
                         |        |
                         +--------+
@end verbatim

We can roughly distinguish four types of filters:

@itemize @bullet
@item
Filters that take one block as input, and output one single block, possibly after removing some sequences, or even the full block if it did not match a certain criterion,
@item
Filters that take one block as input, and split them into several smaller blocks, for instance of a fixed size,
@item
Filters that take several blocks as input and output a larger one, typically after concatenating the input blocks,
@item
Filters that do not modify the input block and simply forward it, yet after having performed some computations, for instance calculating various statistics.
@end itemize

A run of MafFilter typically consists in a workflow of filters, applied in a serial way, the output of one filter being taken as input as the next one.
In the current version of MafFilter, only linear workflows are possible, without branching:

@verbatim
    +----------+    +----------+    +----------+
    |          |    |          |    |          |
--->+ Filter 1 +--->+ Filter 2 +--->+ Filter 3 +---> Etc.
    |          |    |          |    |          |
    +----------+    +----------+    +----------+
@end verbatim

Branching processes can however be achieved by outputing the alignment blocks at the branching point, and run various instances of MafFilter on the resulting files:

@verbatim
     Run 1
    +----------+    +----------+    +----------+
    |          |    |          |    |          |
--->+ Filter 1 +--->+ Filter 2 +--->+ Filter 3 +---> Etc.
    |          |    |          |    |          |
    +----------+    +----+-----+    +----------+
                         |
                         |    +------------+
                         |    |            |
     Run 2               +--->+ Filter 2.1 +---> Etc.
                              |            |
                              +------------+
@end verbatim


The next section describes how to specify the series of filters to be applied, and the next chapter provides an exhaustive list of available filters.

@c ------------------------------------------------------------------------------------------------------------------

@node Run, General, Description, Introduction
@section How to run the program

MafFilter is a program written in C++ with the Bio++ libraries. It is a command line program (that is, without graphical user interface) which uses the Bio++ Options (BppO) syntax. 
This syntax is of type @samp{keys}=@samp{values}, which can be passed directly as arguments of the maffilter program, or more conveniently, stored in an ``options'' file, or a combination of both. See the Bio++ Program Suite (BppSuite) manual for more information.
MafFilter therefore typically takes as input a MAF file and a series of commands which determine the output file(s) that will be written and where.
Additional input files might be specified, such as gene annotation files (typically in GFF/GTF format).

Here is the structure of a minimal option file:

@verbatim
DATA=example.file //A user-defined variable, representing the input maf file, without extension
input.file=$(DATA).maf.gz  //Input maf file, gzipped
input.file.compression=gzip
output.log=$(DATA).maffilter.log //Output log file
maf.filter= //A coma separated list of filters, here empty (the program only read the input file and exits).
@end verbatim

Please refer to the Bio++ Program Suite manual for more details, including the use of variables, priority of option values, etc.

@c ------------------------------------------------------------------------------------------------------------------

@node General,  , Run, Introduction
@section General options

@table @command

@item input.file=@{path@}
The MAF file to parse

@item input.file.compression=[none|zip|gzip|bzip2]
The compression format of the input file.

@item input.format=@{Maf|Fasta@}
MafFilter takes by default a MAF file. It is, however, possible to use a fasta file as input,
which will lead MafFilter to run in "single sequence" mode.
In this mode, each sequence of the original file is considered as a distinct block.
This mode might be useful to extract annotations and estimate simple statistics.
Fasta files can be compressed in the same way as MAF files.

@item output.log=@{path@}
The file where to write log messages.

@item maf.filter=@{Filter1, Filter2, ...@}
The main command, specifying the list of filter commands to apply, in the given order (that is, the input of filter 2 will be the output of filter 1).
Filters take a series of arguments, specified within parentheses: @command{Filter(arg1=opt1, arg2=opt2, etc)}.
The next section present all available filters and their corresponding arguments.
@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Filters,  , Introduction, Top
@chapter Filters

@c ------------------------------------------------------------------------------------------------------------------

@menu
* Extracting::                  
* Cleaning::                    
* Analyzing::                   
* Exporting::                   
@end menu

@node Extracting, Cleaning, Filters, Filters
@section Extracting data

@menu
* Subset::                      
* Merge::                       
* Concatenate::                 
* FeatureFilter::               
* SelectChr::                   
@end menu

@c ------------------------------------------------------------------------------------------------------------------

@node Subset, Merge, Extracting, Extracting
@subsection Subset: remove sequences from blocks by species name

The @command{Subset} filter allows to filter sequences for each block by keeping only a selection of species.
It takes the following arguments, separated by comas:

@table @command
@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species. Only sequences corresponding to the selected species will be kept.
Block without sequences from the selection will be discarded.

@item strict=yes/no
If set to yes, only block containing at least one sequence from each species in the selection will be kept.
        
@item keep=yes/no
If strict is set to yes, tells if additional sequences should be kept in the block, or remove so that the output blocks only contain species from the selection.
        
@item remove_duplicates=yes/no
Only keep blocks for which only one sequence for each species is present. Blocks with paralogous sequences in at least one species will therefore be discarded. 

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Merge, Concatenate, Subset, Extracting
@subsection Merging: merge synthenic blocks

The @command{Merge} filter fuses consecutive blocks based on their coordinates.
Blocks will be fused only if the sequences from a specified set of species can be considered as syntenic.
Two sequences are considered as syntenic if:
@itemize @bullet
@item
they are from the same species
@item
they are from the same chromosome
@item
they are from the same strand
@item
they are distant by less than a defined threshold (the start of sequence 2 - the end of sequence 1 < threshold in bp).
@end itemize

The filter takes the following arguments:

@table @command

@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species.
These species only will be used for the synteny check.
Other species will be concatenated in any situation, and their coordinates removed.

@item dist_max=@{int@}
Maximum distance (in nt) to consider sequences as syntenic.
If dist_max is greater than 0, sequences will be filled with 'N' to preserve coordinates when they are fused.

@item ignore_chr=@{none | (list)@}
An optional parenthetic list of chromosomes to ignore (typically "Unknown", or "Random", etc.).
Sequences annotated with such chromosomes will not be checked for synteny and the corresponding block will not be fused.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Concatenate, FeatureFilter, Merge, Extracting
@subsection Concatenating: merge consecutive blocks up to a certain size

The @command{Concatenate} filter fuses consecutive blocks until the concatenated block reaches a minimal size.

@table @command

@item minimum_size=@{int@}
The minimum size for the blocks to be reached.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node FeatureFilter, SelectChr, Concatenate, Extracting
@subsection Extract features from the alignment

The @command{FeatureFilter} extracts parts of the alignment corresponding to certain features.
The features to extract are typically provided via a GFF file. 

@table @command

@item ref_species=@{string@}
The name of the species for which the coordinates of the features are provided.

@item feature.file=@{path@}
The file where the features are described.

@item feature.file.compression=@{none|gzip|zip|bzip2@}
Compression format for the feature file.

@item feature.format=@{GFF|GTF@}
Format for the feature file, currently GFF (v3.0) or GTF only.

@item file=@{none|@{path@}@}
An optional file were extracted features will be stored, in the MAF format.

@item compression=@{none|gzip|zip|bzip2@}
Compression format for output file (if file != none).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node SelectChr,  , FeatureFilter, Extracting
@subsection Extract blocks for a given chromosome/contig/scaffold

The @command{SelectChr} filter keeps only block from a given chromosome (or contig or scaffold...) for a given reference species.

@table @command

@item ref_species=@{string@}
The species name for which chromosomes should be extracted.

@item chromosome=@{string@}
The name of the chromosome/contig/scaffold to be filtered.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Cleaning, Analyzing, Extracting, Filters
@section Cleaning alignment blocks

@c ------------------------------------------------------------------------------------------------------------------

@menu
* MinBlockLength::              
* MinBlockSize::                
* XFullGap::                    
* AlnFilter::                   
* AlnFilter2::                  
* EntropyFilter::               
* MaskFilter::                  
* QualFilter::                  
@end menu

@node MinBlockLength, MinBlockSize, Cleaning, Cleaning
@subsection Minumum block length

The @command{MinBlockLength} filter discards blocks with less sites than a given threshold.

@table @command

@item min_length=@{int>0@}
The minimum length.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node MinBlockSize, XFullGap, MinBlockLength, Cleaning
@subsection Minumum block size

The @command{MinBlockSize} filter discards blocks with less sequences than a given threshold.

@table @command

@item min_size=@{int>0@}
The minimum size.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node XFullGap, AlnFilter, MinBlockSize, Cleaning
@subsection Exclude full gap columns

Remove gap-only columns from blocks. This does not modify coordinates and might be necessary after a @command{Subset} filter.

@table @command

@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species. Any column containing a gap in the specified species will be removed. If other species are present in the block, the corresponding character will be removed, whether it is a gap or not. The coordinates of these species will then be discarded.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node AlnFilter, AlnFilter2, XFullGap, Cleaning
@subsection Alignment filtering

Split alignment blocks by removing regions with ambiguous alignments.
The local uncertainty in the alignment is determined through a sliding window based approach.
For each window, the number of gap characters and the total entropy are computed. Any window
for which both the entropy and number of gaps exceed the given thresholds will be removed from
the alignment, and the corresponding block split accordingly.

@table @command

@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species. All calculations will be performed on the sub-alignment corresponding to these species only.

@item window.size=@{int>0@}
The width, in bp, of the sliding window.

@item window.step=@{int>0@}
The step by which the window is moved, in bp.

@item max.gap=@{int>0@}
The maximum number of gaps allowed in each window.

@item max.ent=@{float@}
The maximum entropy allowed in each window.

@item missing_as_gap=@{yes/no@}
Tell if unresolved characters should be counted as gaps.

@item file=@{none|@{path@}@}
An optional file were removed alignment parts will be stored, in the MAF format.
This can be helpful for visual inspection and fine tuning of the filter parameters.

@item compression=@{none|gzip|zip|bzip2@}
Compression format for output file (if file != none).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node AlnFilter2, EntropyFilter, AlnFilter, Cleaning
@subsection Alignment filtering 2

This is another algorithm for cleaning alignment blocks (see AlnFilter), using sliding windows.
The number of gaps in each alignment column in the window is counted, and the column is masked if it contains more than a given threshold of gaps. consecutive patterns in the window are only counted ones. In the follwing 10nt window:
@verbatim
AATCGGGCGT
AA---GCGGA
AA---CGGGT
CA---CGGGA
@end verbatim
positions 3, 4 and 5 will be masked if the maximum number of gaps allowed is 2 or less. The three columns will however count as only one indel event.
The window is then discarded if it contains more than a given number of indel events.

@table @command

@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species. All calculations will be performed on the sub-alignment corresponding to these species only.

@item window.size=@{int>0@}
The width, in bp, of the sliding window.

@item window.step=@{int>0@}
The step by which the window is moved, in bp.

@item max.gap=@{int>0@}
The maximum number of gaps allowed in each site.

@item max.pos=@{int>0@}
The maximum number of positions with gaps (``indel events'').

@item missing_as_gap=@{yes/no@}
Tell if unresolved characters should be counted as gaps.

@item file=@{none|@{path@}@}
An optional file were removed alignment parts will be stored, in the MAF format.
This can be helpful for visual inspection and fine tuning of the filter parameters.

@item compression=@{none|gzip|zip|bzip2@}
Compression format for output file (if file != none).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node EntropyFilter, MaskFilter, AlnFilter2, Cleaning
@subsection Entropy filtering

This filter removes highly variable regions and split the blocks accordingly.
It uses a sliding windows, and compute the entropy for each site in the window.
The window is then discarded if it containes more than 'p' sites with an entropy higher that a user-specified threshold. The alignment block is then split into separate block accordingly.

@table @command

@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species. All calculations will be performed on the sub-alignment corresponding to these species only.

@item window.size=@{int>0@}
The width, in bp, of the sliding window.

@item window.step=@{int>0@}
The step by which the window is moved, in bp.

@item max.ent=@{float@}
The maximum entropy allowed at each site.

@item max.pos=@{int>0@}
The maximum number of positions with an entropy higher than the given threshold.

@item missing_as_gap=@{yes/no@}
Tell if unresolved characters should be counted as gaps.

@item ignore_gaps=@{yes/no@}
Tell if gaps should not be counted in entropy calculation. If no, then gaps are counted as a ``fifth'' state.

@item file=@{none|@{path@}@}
An optional file were removed alignment parts will be stored, in the MAF format.
This can be helpful for visual inspection and fine tuning of the filter parameters.

@item compression=@{none|gzip|zip|bzip2@}
Compression format for output file (if file != none).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node MaskFilter, QualFilter, EntropyFilter, Cleaning
@subsection Masked sequences filtering

The @command{MaskFilter} split alignment blocks by removing regions with too many masked positions (typically showing repeat-content), using sliding windows.
A masked position is identified by a lower case letter in the original sequence.
Windows with more than a given amount of lower case characters will be discarded, and the corresponding block split.

@table @command

@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species. All calculations will be performed on the sub-alignment corresponding to these species only.

@item window.size=@{int>0@}
The width, in bp, of the sliding window.

@item window.step=@{int>0@}
The step by which the window is moved, in bp.

@item max.masked=@{int>0@}
The maximum number of lower-case characters allowed in each window.

@item file=@{none|@{path@}@}
An optional file were removed alignment parts will be stored, in the MAF format.
This can be helpful for visual inspection and fine tuning of the filter parameters.

@item compresion=@{none|gzip|zip|bzip2@}
Compression format for output file (if file != none).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node QualFilter,  , MaskFilter, Cleaning
@subsection Quality filtering

The @command{QualFilter} split alignment blocks by removing regions with too low quality score.
Windows with an average quality below a given threshold will be discarded, and the corresponding block split.

@table @command

@item species=(species1, species2, etc)
A coma separated, within parentheses, list of species. All calculations will be performed on the sub-alignment corresponding to these species only. The corresponding sequences must have a quality score line in the original file.

@item window.size=@{int>0@}
The width, in bp, of the sliding window.

@item window.step=@{int>0@}
The step by which the window is moved, in bp.

@item min.qual=@{double@}
The minimum average quality allowed for each window.

@item file=@{none|@{path@}@}
An optional file were removed alignment parts will be stored, in the MAF format.
This can be helpful for visual inspection and fine tuning of the filter parameters.

@item compression=@{none|gzip|zip|bzip2@}
Compression format for output file (if file != none).

@end table

@c ------------------------------------------------------------------------------------------------------------------


@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------

@node Analyzing, Exporting, Cleaning, Filters
@section Statistical analysis

@c ------------------------------------------------------------------------------------------------------------------
@node Exporting,  , Analyzing, Filters
@section Exporting blocks and data

@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------
@c ------------------------------------------------------------------------------------------------------------------

@c end of document

@c @node Index,  , Reference, Top
@c @unnumbered Index
@c
@c @printindex cp


@bye
